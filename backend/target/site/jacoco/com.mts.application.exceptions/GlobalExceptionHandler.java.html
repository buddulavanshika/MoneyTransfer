<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GlobalExceptionHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">backend</a> &gt; <a href="index.source.html" class="el_package">com.mts.application.exceptions</a> &gt; <span class="el_source">GlobalExceptionHandler.java</span></div><h1>GlobalExceptionHandler.java</h1><pre class="source lang-java linenums">package com.mts.application.exceptions;

import com.mts.domain.exceptions.AccountNotActiveException;
import com.mts.domain.exceptions.AccountNotFoundException;
import com.mts.domain.exceptions.DuplicateTransferException;
import com.mts.domain.exceptions.InsufficientBalanceException;
import com.mts.domain.exceptions.OptimisticLockException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice; // Prefer this to get JSON by default

import java.util.Map;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.OffsetDateTime;
import java.util.HashMap;

@RestControllerAdvice
<span class="fc" id="L28">public class GlobalExceptionHandler {</span>

    @ExceptionHandler(AccountNotFoundException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleAccountNotFound(
            AccountNotFoundException ex, HttpServletRequest request) {
<span class="nc" id="L33">        return buildErrorResponse(</span>
                &quot;ACCOUNT_NOT_FOUND&quot;,
<span class="nc" id="L35">                ex.getMessage(),</span>
                HttpStatus.NOT_FOUND,
                request,
                null
        );
    }

    @ExceptionHandler(InsufficientBalanceException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleInsufficientBalance(
            InsufficientBalanceException ex, HttpServletRequest request) {
<span class="nc" id="L45">        return buildErrorResponse(</span>
                &quot;INSUFFICIENT_BALANCE&quot;,
<span class="nc" id="L47">                ex.getMessage(),</span>
                HttpStatus.BAD_REQUEST,
                request,
                null
        );
    }

    @ExceptionHandler(AccountNotActiveException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleAccountNotActive(
            AccountNotActiveException ex, HttpServletRequest request) {
<span class="nc" id="L57">        return buildErrorResponse(</span>
                &quot;ACCOUNT_NOT_ACTIVE&quot;,
<span class="nc" id="L59">                ex.getMessage(),</span>
                HttpStatus.FORBIDDEN,
                request,
                null
        );
    }

    @ExceptionHandler(DuplicateTransferException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleDuplicateTransfer(
            DuplicateTransferException ex, HttpServletRequest request) {
<span class="nc" id="L69">        return buildErrorResponse(</span>
                &quot;DUPLICATE_TRANSFER&quot;,
<span class="nc" id="L71">                ex.getMessage(),</span>
                HttpStatus.CONFLICT,
                request,
                null
        );
    }

    @ExceptionHandler(OptimisticLockException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleOptimisticLock(
            OptimisticLockException ex, HttpServletRequest request) {
<span class="nc" id="L81">        return buildErrorResponse(</span>
                &quot;CONCURRENT_MODIFICATION&quot;,
<span class="nc" id="L83">                ex.getMessage(),</span>
                HttpStatus.CONFLICT,
                request,
                null
        );
    }

    // ===== Persistence / Idempotency conflicts =====

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleDuplicateKey(
            DataIntegrityViolationException ex, HttpServletRequest request) {
        // You can inspect ex.getCause()/constraint name to be more specific if needed.
<span class="nc" id="L96">        Map&lt;String, Object&gt; details = Map.of(</span>
                &quot;reason&quot;, &quot;Unique constraint violated (likely idempotency key)&quot;,
                &quot;hint&quot;, &quot;Reuse the same idempotency key only for the same request payload&quot;
        );
<span class="nc" id="L100">        return buildErrorResponse(</span>
                &quot;DUPLICATE_REQUEST&quot;,
                &quot;Request already processed with the same idempotency key&quot;,
                HttpStatus.CONFLICT,
                request,
                details
        );
    }

    // ===== Validation &amp; binding =====

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, HttpServletRequest request) {

<span class="fc" id="L115">        Map&lt;String, String&gt; fieldErrors = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">        for (FieldError fe : ex.getBindingResult().getFieldErrors()) {</span>
<span class="fc" id="L117">            fieldErrors.put(fe.getField(), fe.getDefaultMessage());</span>
<span class="fc" id="L118">        }</span>

<span class="fc" id="L120">        Map&lt;String, Object&gt; details = new HashMap&lt;&gt;();</span>
<span class="fc" id="L121">        details.put(&quot;fieldErrors&quot;, fieldErrors);</span>

<span class="fc" id="L123">        return buildErrorResponse(</span>
                &quot;VALIDATION_FAILED&quot;,
                &quot;One or more fields are invalid&quot;,
                HttpStatus.UNPROCESSABLE_ENTITY,
                request,
                details
        );
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleConstraintViolation(
            ConstraintViolationException ex, HttpServletRequest request) {

<span class="nc" id="L136">        Map&lt;String, String&gt; violations = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        for (ConstraintViolation&lt;?&gt; v : ex.getConstraintViolations()) {</span>
            // propertyPath like &quot;transfer.request.amount&quot;
<span class="nc" id="L139">            violations.put(v.getPropertyPath().toString(), v.getMessage());</span>
<span class="nc" id="L140">        }</span>

<span class="nc" id="L142">        Map&lt;String, Object&gt; details = new HashMap&lt;&gt;();</span>
<span class="nc" id="L143">        details.put(&quot;violations&quot;, violations);</span>

<span class="nc" id="L145">        return buildErrorResponse(</span>
                &quot;CONSTRAINT_VIOLATION&quot;,
                &quot;Validation constraints violated&quot;,
                HttpStatus.UNPROCESSABLE_ENTITY,
                request,
                details
        );
    }

    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleTypeMismatch(
            MethodArgumentTypeMismatchException ex, HttpServletRequest request) {

<span class="nc" id="L158">        Map&lt;String, Object&gt; details = Map.of(</span>
<span class="nc" id="L159">                &quot;name&quot;, ex.getName(),</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                &quot;requiredType&quot;, ex.getRequiredType() != null ? ex.getRequiredType().getSimpleName() : null,</span>
<span class="nc" id="L161">                &quot;value&quot;, ex.getValue()</span>
        );

<span class="nc" id="L164">        return buildErrorResponse(</span>
                &quot;TYPE_MISMATCH&quot;,
                &quot;Request parameter type is invalid&quot;,
                HttpStatus.BAD_REQUEST,
                request,
                details
        );
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleNotReadable(
            HttpMessageNotReadableException ex, HttpServletRequest request) {

        // Often thrown for malformed JSON, wrong enum values, etc.
<span class="nc" id="L178">        return buildErrorResponse(</span>
                &quot;MALFORMED_REQUEST&quot;,
                &quot;Request body is invalid or unreadable&quot;,
                HttpStatus.BAD_REQUEST,
                request,
                null
        );
    }

    // ===== Catch-all fallback =====

    @ExceptionHandler(Exception.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleGeneric(
            Exception ex, HttpServletRequest request) {

        // Avoid leaking internal details; log full stack trace in a logger/aspect.
<span class="nc" id="L194">        return buildErrorResponse(</span>
                &quot;INTERNAL_ERROR&quot;,
                &quot;An unexpected error occurred&quot;,
                HttpStatus.INTERNAL_SERVER_ERROR,
                request,
                null
        );
    }

    // ===== Helper &amp; model =====

    private ResponseEntity&lt;ErrorResponse&gt; buildErrorResponse(
            String code,
            String message,
            HttpStatus status,
            HttpServletRequest request,
            Map&lt;String, Object&gt; details
    ) {
<span class="fc" id="L212">        ErrorResponse error = new ErrorResponse(</span>
                code,
                message,
<span class="fc" id="L215">                status.value(),</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">                request != null ? request.getRequestURI() : null,</span>
<span class="fc" id="L217">                OffsetDateTime.now().toString(),</span>
<span class="fc" id="L218">                correlationId(request),</span>
                details
        );
<span class="fc" id="L221">        return ResponseEntity.status(status).body(error);</span>
    }

    private String correlationId(HttpServletRequest request) {
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if (request == null) return null;</span>
        // If you add a filter that sets/propagates a correlation id header (e.g., X-Correlation-Id),
        // read it here to include in all error responses:
<span class="fc" id="L228">        String cid = request.getHeader(&quot;X-Correlation-Id&quot;);</span>
<span class="pc bpc" id="L229" title="3 of 4 branches missed.">        return (cid == null || cid.isBlank()) ? null : cid;</span>
    }

    public static final class ErrorResponse {
        private final String code;
        private final String message;
        private final int status;
        private final String path;
        private final String timestamp;
        private final String correlationId;
        private final Map&lt;String, Object&gt; details;

        public ErrorResponse(String code, String message, int status, String path,
<span class="fc" id="L242">                             String timestamp, String correlationId, Map&lt;String, Object&gt; details) {</span>
<span class="fc" id="L243">            this.code = code;</span>
<span class="fc" id="L244">            this.message = message;</span>
<span class="fc" id="L245">            this.status = status;</span>
<span class="fc" id="L246">            this.path = path;</span>
<span class="fc" id="L247">            this.timestamp = timestamp;</span>
<span class="fc" id="L248">            this.correlationId = correlationId;</span>
<span class="fc" id="L249">            this.details = details;</span>
<span class="fc" id="L250">        }</span>

<span class="fc" id="L252">        public String getCode() { return code; }</span>
<span class="fc" id="L253">        public String getMessage() { return message; }</span>
<span class="fc" id="L254">        public int getStatus() { return status; }</span>
<span class="fc" id="L255">        public String getPath() { return path; }</span>
<span class="fc" id="L256">        public String getTimestamp() { return timestamp; }</span>
<span class="fc" id="L257">        public String getCorrelationId() { return correlationId; }</span>
<span class="fc" id="L258">        public Map&lt;String, Object&gt; getDetails() { return details; }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>